# 지혜롭게 구간의 합을 구할 수 있는 알고리즘, 누적 합!

안녕하세요! 저는 요술토끼라고 합니다.
오늘은 구간의 합을 빠르게 구할 수 있는, **누적 합** 알고리즘에 대해 설명하고자 합니다.
지루한 주제가 될 수 있으니, 이야기를 하면서 시작해 볼까요?

## 하트 여왕과 카드 더하기 게임

<p align="center">
  <img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/9155a80f-6ef4-4ca1-b1fd-1ecc97584060" width="700px"/>
</p>

어쩌다가 하트 여왕의 왕국 안에서 눈을 뜬 앨리스. 원래 세계로 돌아가려면, 하트 여왕과 카드 게임을 해서 이겨야만 합니다.

규칙은 간단합니다. 하트 여왕이 카드를 일렬로 늘어놓고, 특정 구간의 카드들을 선택한 뒤, 이 카드들의 합을 묻습니다. 합을 정확하게 대답한다면 게임에서 이기게 됩니다. 원래 세계로 돌아가기 위해, 앨리스는 게임에 응했고, 여왕은 질문을 하기 시작했습니다.

### #1

> $3$ 번째 카드부터 $6$ 번째 카드까지 적힌 수를 모두 더한 합은?

$3$ 번째 카드부터 $6$ 번째 카드까지 적힌 수는 각각 $3$, $5$, $2$, $4$ 이므로, 앨리스는 간단한 덧셈으로 $3 + 5 + 2 + 4 = 14$ 를 외쳤습니다.

### #2

화가 난 여왕은 카드의 수를 무려 $1\\;000\\;000$ 장으로 늘렸습니다. 그리고 이전 방식과 동일하게 구간을 정해 앨리스에게 카드의 합을 물었습니다.

> $x$ 번째 카드부터 $y$ 번째 카드까지 적힌 수를 모두 더한 합은? ($1 \le x \le y \le 1\\;000\\;000$)

카드의 수가 엄청나게 많아졌지만, 앨리스는 노트북을 가지고 있었기에, $x$ 번째 카드부터 $y$ 번째 카드까지 일일이 더하는 코드를 작성해 합을 계산할 수 있었습니다.

```cpp

int sum = 0;

for (int i = x; i <= y; i++) {
    sum += cards[i];
}

cout << sum;
```

### #3

화가 머리끝까지 난 여왕은 앨리스가 도저히 합을 구할 수 없도록, 엄청나게 많은 수의 질문을 하기로 했습니다.

> $x$ 번째 카드부터 $y$ 번째 카드까지의 합을 맞춰 봐. 그런데 나는 너한테 이 질문을 최대 $1\\;000\\;000$ 번까지 할 거고, 질문을 할 때마다 $x$ 값과 $y$ 값은 새롭게 정할 거야. ($1 \le x \le y \le 1\\;000\\;000$)

앨리스도 이번에는 여러 번 $x$ 와 $y$ 를 입력받아 합을 계산하려고 했지만, 이번에는 문제가 생겼습니다. 합을 구하는 데 너무 시간이 오래 걸린 나머지, 앨리스는 답을 구하지 못 했고, 게임에서 지게 되었습니다.

```cpp
for (int t = 1; t <= 1000000; t++) {
    int sum = 0;
    cin >> x >> y;

    for (int i = x; i <= y; i++) {
        sum += cards[i];
    }

    cout << sum;
}
```

## 왜 앨리스의 코드는 시간이 너무 오래 걸렸던 걸까요

### 컴퓨터는 1초에 이 정도의 연산을 할 수 있어요

**알고리즘 문제풀이에서, 컴퓨터가 $1$ 초에 할 수 있는 연산의 횟수는 보통 수 억번 정도로 두는 경우가 많아요.** 물론 이 연산의 횟수는 연산 한 번당 얼마나 많은 시간이 걸리는지, 얼마나 연산이 무거운지에 따라 달라질 수는 있어요.

### 최악의 상황을 가정해 볼까요

**알고리즘은 주어진 조건 내에서 어떤 입력이 주어지든, 안정적인 시간 안에 답을 낼 수 있어야 해요. 입력이 가장 많고 복잡한 최악의 상황이 주어져도 말이죠.**

하트 여왕의 카드 게임에서는, 카드가 $1\\;000\\;000$ 장이고, 여왕이 질문을 $1\\;000\\;000$ 번 하며, 매 질문마다 $1\\;000\\;000$ 장의 카드 모두의 합을 계산하라고 묻는 것이 최악의 상황일 거에요.

매 질문마다 앨리스가 작성한 프로그램은 $1\\;000\\;000$ 장의 카드를 모두 확인해 볼 것이고, 이 상황이 $1\\;000\\;000$ 번 반복될 것이기에, 카드의 수를 $N$, 질문의 수를 $M$ 이라 한다면 앨리스의 코드의 시간복잡도는 $O(NM)$ 이 되고, 연산 횟수는 무려 $1\\;000\\;000\\;000\\;000$ 회나 될 것입니다. $1$ 초에 할 수 있는 연산의 수를 수억 번이라 가정했을 때 상당히 오랜 시간이 걸릴 것이라는 것을 알 수 있고, 앨리스의 프로그램이 바로 답을 출력하지 못 할 것이라는 사실 역시 알 수 있어요.

따라서, 앨리스가 작성한 코드는 여왕의 질문에 모두 대답하기에는 너무 비효율적이에요. 더 효율적으로 합을 계산하고 앨리스가 게임을 이기게 할 방법은 없을까요?

## 누적 합을 이용해, 더 효율적으로 합을 구해 봅시다!

다행히도, 앨리스가 여왕의 질문에 모두 대답하고 게임을 이길 수 있는 방법은 여전히 있답니다! 누적 합 알고리즘과 함께라면 가능해요.

**누적 합** 알고리즘은 **특정 구간에 있는 연속된 수들의 합을 빠르게 구할 수 있는** 알고리즘이에요. **수들의 합을 미리 저장해 두었다가, 필요할 때 재사용하는 방식**을 사용하여 붋필요한 연산을 줄이고 시간을 대폭 줄일 수 있답니다.

### 누적 합 배열 만들기

누적 합 알고리즘을 사용하려면 먼저 수들의 합을 미리 저장해 둔 **누적 합 배열**이 필요해요. 이 배열을 먼저 만들어 봅시다.

누적 합 배열을 만들 때에는 **누적 합 배열의 $i$ 번째 값이 $1$ 번째 값부터 $i$ 번째 값**까지의 합이 되도록 채우면 돼요. 한 번 해 볼까요?

> 누적 합의 첫 번째 값은 배열의 첫 번째 값과 같아요.

<p align="center">
<img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/80d61aad-8a80-40c2-9b35-8664b823b991" width="700px">
</p>

배열의 첫 번째 값까지 더한 합은 배열의 첫 번째 값과 같기 때문이에요.

> 두 번째 값부터 채울 때에는, 직전에 구했던 합과 현재 배열의 값을 더한 값을 저장해요.

<p align="center">
   <img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/6aaf6799-cb29-4d4b-a2a7-5bc56c8c4813" width="700px">
   </p>

예를 들면 누적 합 배열의 $i$ 번째 값을 채울 때는 $(i - 1)$ 번째 누적 합 배열의 값과 배열의 $i$ 번째 값을 더한 것이 돼요. 식으로 나타낸다면 아래와 같겠죠!

<p align="center">$prefix[i] = prefix[i - 1] + array[i]$</p>

이렇게 계산한다면, 누적 합 배열의 각 값을 채울 때 일일이 첫 번째부터 $i$ 번째 값까지 더하는 비효율적인 방법을 사용하지 않아도 됩니다!

위의 과정을 모두 마치셨다면, 누적 합 배열은 완성입니다! 이제 만든 누적 합 배열을 이용해 효율적으로 구간의 합을 구하고, 여왕의 질문에 대답해 봅시다!

<p align="center">
<img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/2a46648b-6b6f-4ec3-ba32-c90bae1e2f9f" width="700px">
</p>

> $x$ 번째 카드부터 $y$ 번째 카드까지 적힌 수를 모두 더한 합은?

먼저, 우리가 계산해야 하는 값은 $y$ 번째 값까지이므로, $1$ 번째 값부터 $y$ 번째 값까지의 합을 먼저 구합니다. 누적 합 배열에서 미리 계산해 두었으니 답을 바로 알아낼 수 있네요!

> $1$ 번째 값부터 $y$ 번째 값까지의 합은 $prefix[y]$ 입니다.

그리고, 이 상태에서 불필요한 구간의 합을 빼 주면 됩니다. 우리가 원하는 값은 $x$ 번째 수부터 $y$ 번째 수이죠? 그렇다면 불필요함에도 불구하고 값이 더해진 구간은 $1$ 번째 수부터 $(x - 1)$ 번째 수까지가 됩니다.

> $1$ 번째 값부터 $(x - 1)$ 번째 값까지의 합은 $prefix[x - 1]$ 이고, 이 부분이 $x$ 번째 수부터 $y$ 번째 수의 합을 구하기 위해 빼 주어야 하는 부분이 됩니다.

따라서, $x$ 번째 값부터 $y$ 번째 값까지의 합은 아래의 식과 같게 됩니다.

<p align="center">$prefix[y] - prefix[x - 1]$</p>

기존 방법인 모든 수를 처음부터 끝까지 일일이 더하는 방식은 시간복잡도가 $O(NM)$ 이었습니다. 반면 누적 합을 만들어 질문에 대답하는 방법은...

- 누적 합을 만드는 데 드는 시간 복잡도 $O(N)$
- 한 번의 질문마다 연산 한 번에 답을 구할 수 있으므로 $O(1)$, $M$ 개의 질문에 답해야 하므로 $O(M)$

으로, 시간복잡도가 $O(N + M)$ 이 됩니다. 연산의 수로 따지자면 $2\\;000\\;000$ 으로, 기존 방식에서의 연산 수인 $1\\;000\\;000\\;000\\;000$ 와는 비교도 안 될 정도로 적은 수입니다.

이처럼 누적 합을 사용하면 보다 효율적으로 구간의 합을 구할 수 있게 됩니다. 앨리스의 궁금증도 해결이 되었겠군요!

## 2차원 배열에서의 누적 합 구하기

지금까지는 1차원 배열에서의 누적 합을 구해보았습니다. 그렇다면 2차원 배열에서는 누적 합을 구할 수 있을까요? 물론이죠! 어렵지만 한 번 해 볼까요?

### 2차원 누적 합의 정의

<p align="center">
<img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/1fd1aa7a-3972-4290-a880-4526a95e3c34" width="700px">
</p>

2차원 누적 합 배열을 만들 때에는 **누적 합 배열의 $r$ 행 $c$ 열의 값이 $1$ 행 $1$ 열과 $r$ 행 $c$ 열을 꼭짓점으로 하는 직사각형의 합이 되도록** 만들면 됩니다. 위 그림과 같이요!

### 2차원 누적 합 만들기

$(r, c)$ 를 배열의 $r$ 행 $c$ 열이라고 했을 때, $R$ 행 $C$ 열 크기의 2차원 누적 합을 채울 때는 아래의 순서로 값을 채우면 됩니다.

<p align="center">
$(1, 1)$, $(1, 2)$, $(1, 3)$, $...$, $(1, C)$, $(2, 1)$, $(2, 2)$, $(2, 3)$, $...$, $(2, C)$, $...$, $(R, C)$
</p>

이제 누적 합의 각 칸을 채우는 것에 주목해 봅시다. 2차원 누적 합의 정의대로 값을 채우려면 아래의 두 값을 합해야 합니다.

<p align="center">
<img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/b874380a-0892-4d70-9089-0aa24450c739" width="450px">
</p>

- 현재 배열의 값 (빨간 부분)
- 직사각형을 이루는 부분 중, 현재 배열의 값을 제외한 부분 (파란 부분)

빨간 부분은 $array[r][c]$ 와 같으므로 쉽게 구할 수 있습니다. 문제는 파란 부분이겠죠? 파란 부분에 해당하는 합을 구하기 위해, 2차원 누적 합을 어떻게 활용할 수 있을까요?

<p align="center">
<img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/550ab795-706c-446d-8496-3528f6ea0ef5" width="350px">
</p>

누적 합 배열의 두 영역을 이용해, 먼저 구하고자 하는 영역을 포개 봅시다. 이 경우 식으로 나타내면 $prefix[r - 1][c] + prefix[r][c - 1]$ 가 됩니다. 물론, 더해진 부분 중에서는 겹치는 부분이 있는데, 이 부분은 합에서 제외되므로 빼 주어야 합니다.

<p align="center">
<img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/95058423-26d4-4e8d-aa84-c61021d3b8ff" width="600px">
</p>

바로 이런 식으로, 두 부분에서 중복해서 더해진 부분을 따로 빼 주면 됩니다. 겹치는 부분을 식으로 나타내면 $prefix[r - 1][c - 1]$ 이 됩니다. 결국, $r$ 행 $c$ 열에 해당하는 누적합 배열의 칸을 채우기 위한 식은 아래와 같게 됩니다!

<p align="center">$prefix[r - 1][c] + prefix[r][c - 1] - prefix[r - 1][c - 1] + array[r][c]$</p>

### 2차원 누적 합 구하기

누적 합 배열을 만들었을 때와 마찬가지로, 2차원 배열에서의 누적 합도 비슷한 방법으로 구할 수 있습니다. $(r_1, c_1)$ 부터 $(r_2, c_2)$ 까지의 영역에 해당하는 직사각형 부분의 누적 합을 구해 봅시다. 예를 들어, 아래 영역에 해당하는 부분의 누적 합을 구한다고 해 보겠습니다.

<p align="center">
<img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/72b0a8b5-3b12-4ded-b791-a0e4e80ccbe6" width="350px">
</p>

<br>

> 우선, 구하고자 하는 범위를 모두 포개도록 $(r, c)$ 영역에 해당하는 누적 합을 더해 줍니다.

<p align="center">
<img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/daa1c770-6c35-4a05-a3b8-61fee3c08bad" width="350px">
</p>

> 그 다음으로는, 이전 단계에서 더한 누적 합에서 영역에 해당하지 않는 부분은 빼 줍니다. 이 과정에서, 두 번 빼 주게 되는 영역이 생기게 됩니다.

<p align="center">
<img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/5d80c083-8980-45bd-8a06-fd83b9f78976" width="350px">
</p>

> 마지막으로, 두 번 빼 주게 된 영역에 해당하는 부분은 다시 한 번 더해 줍니다.

<p align="center">
<img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/b90fdec6-7ec1-4142-b82f-106804a504ef" width="350px">
</p>

위의 단계를 모두 거친다면, 해당하는 영역의 누적합을 구할 수 있게 됩니다! 식으로 나타내면, ...

<p align="center">$prefix[r_2][c_2] - prefix[r_2][c_1 - 1] - prefix[r_1 - 1][c_2] + array[r_1 - 1][c_1 - 1]$</p>

와 같게 됩니다!
