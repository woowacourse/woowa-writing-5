# 지혜롭게 구간의 합을 구할 수 있는 알고리즘, 누적 합!

안녕하세요! 저는 요술토끼라고 합니다.
오늘은 구간의 합을 빠르게 구할 수 있는, **누적 합** 알고리즘에 대해 설명하고자 합니다.
지루한 주제가 될 수 있으니, 이야기를 하면서 시작해 볼까요?

## 하트 여왕과 카드 더하기 게임

<p align="center">
  <img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/9155a80f-6ef4-4ca1-b1fd-1ecc97584060" width="700px"/>
</p>

어쩌다가 하트 여왕의 왕국 안에서 눈을 뜬 앨리스. 원래 세계로 돌아가려면, 하트 여왕과 카드 게임을 해서 이겨야만 합니다.

규칙은 간단합니다. 하트 여왕이 카드를 일렬로 늘어놓고, 특정 구간의 카드들을 선택한 뒤, 이 카드들의 합을 묻습니다. 합을 정확하게 대답한다면 게임에서 이기게 됩니다. 원래 세계로 돌아가기 위해, 앨리스는 게임에 응했고, 여왕은 질문을 하기 시작했습니다.

### #1

> $3$ 번째 카드부터 $6$ 번째 카드까지 적힌 수를 모두 더한 합은?

$3$ 번째 카드부터 $6$ 번째 카드까지 적힌 수는 각각 $3$, $5$, $2$, $4$ 이므로, 앨리스는 간단한 덧셈으로 $3 + 5 + 2 + 4 = 14$ 를 외쳤습니다.

### #2

화가 난 여왕은 카드의 수를 무려 $1\\;000\\;000$ 장으로 늘렸습니다. 그리고 이전 방식과 동일하게 구간을 정해 앨리스에게 카드의 합을 물었습니다.

> $x$ 번째 카드부터 $y$ 번째 카드까지 적힌 수를 모두 더한 합은? ($1 \le x \le y \le 1\\;000\\;000$)

카드의 수가 엄청나게 많아졌지만, 앨리스는 노트북을 가지고 있었기에, $x$ 번째 카드부터 $y$ 번째 카드까지 일일이 더하는 코드를 작성해 합을 계산할 수 있었습니다.

```cpp

int sum = 0;

for (int i = x; i <= y; i++) {
    sum += cards[i];
}

cout << sum;
```

### #3

화가 머리끝까지 난 여왕은 앨리스가 도저히 합을 구할 수 없도록, 엄청나게 많은 수의 질문을 하기로 했습니다.

> $x$ 번째 카드부터 $y$ 번째 카드까지의 합을 맞춰 봐. 그런데 나는 너한테 이 질문을 최대 $1\\;000\\;000$ 번까지 할 거고, 질문을 할 때마다 $x$ 값과 $y$ 값은 새롭게 정할 거야. ($1 \le x \le y \le 1\\;000\\;000$)

앨리스도 이번에는 여러 번 $x$ 와 $y$ 를 입력받아 합을 계산하려고 했지만, 이번에는 문제가 생겼습니다. 합을 구하는 데 너무 시간이 오래 걸린 나머지, 앨리스는 답을 구하지 못 했고, 게임에서 지게 되었습니다.

```cpp
for (int t = 1; t <= 1000000; t++) {
    int sum = 0;
    cin >> x >> y;

    for (int i = x; i <= y; i++) {
        sum += cards[i];
    }

    cout << sum;
}
```

## 왜 앨리스의 코드는 시간이 너무 오래 걸렸던 걸까요

### 컴퓨터는 1초에 이 정도의 연산을 할 수 있어요

**알고리즘 문제풀이에서, 컴퓨터가 $1$ 초에 할 수 있는 연산의 횟수는 보통 수 억번 정도로 두는 경우가 많아요.** 물론 이 연산의 횟수는 연산 한 번당 얼마나 많은 시간이 걸리는지, 얼마나 연산이 무거운지에 따라 달라질 수는 있어요.

### 최악의 상황을 가정해 볼까요

**알고리즘은 주어진 조건 내에서 어떤 입력이 주어지든, 안정적인 시간 안에 답을 낼 수 있어야 해요. 입력이 가장 많고 복잡한 최악의 상황이 주어져도 말이죠.**

하트 여왕의 카드 게임에서는, 카드가 $1\\;000\\;000$ 장이고, 여왕이 질문을 $1\\;000\\;000$ 번 하며, 매 질문마다 $1\\;000\\;000$ 장의 카드 모두의 합을 계산하라고 묻는 것이 최악의 상황일 거에요.

매 질문마다 앨리스가 작성한 프로그램은 $1\\;000\\;000$ 장의 카드를 모두 확인해 볼 것이고, 이 상황이 $1\\;000\\;000$ 번 반복될 것이기에, 카드의 수를 $N$, 질문의 수를 $M$ 이라 한다면 앨리스의 코드의 시간복잡도는 $O(NM)$ 이 되고, 연산 횟수는 무려 $1\\;000\\;000\\;000\\;000$ 회나 될 것입니다. $1$ 초에 할 수 있는 연산의 수를 수억 번이라 가정했을 때 상당히 오랜 시간이 걸릴 것이라는 것을 알 수 있고, 앨리스의 프로그램이 바로 답을 출력하지 못 할 것이라는 사실 역시 알 수 있어요.

따라서, 앨리스가 작성한 코드는 여왕의 질문에 모두 대답하기에는 너무 비효율적이에요. 더 효율적으로 합을 계산하고 앨리스가 게임을 이기게 할 방법은 없을까요?

## 누적 합을 이용해, 더 효율적으로 합을 구해 봅시다!

다행히도, 앨리스가 여왕의 질문에 모두 대답하고 게임을 이길 수 있는 방법은 여전히 있답니다! 누적 합 알고리즘과 함께라면 가능해요.

**누적 합** 알고리즘은 **특정 구간에 있는 연속된 수들의 합을 빠르게 구할 수 있는** 알고리즘이에요. **수들의 합을 미리 저장해 두었다가, 필요할 때 재사용하는 방식**을 사용하여 붋필요한 연산을 줄이고 시간을 대폭 줄일 수 있답니다.

### 누적 합 배열 만들기

누적 합 알고리즘을 사용하려면 먼저 수들의 합을 미리 저장해 둔 **누적 합 배열**이 필요해요. 이 배열을 먼저 만들어 봅시다.

누적 합 배열을 만들 때에는 **누적 합 배열의 $i$ 번째 값이 $1$ 번째 값부터 $i$ 번째 값**까지의 합이 되도록 채우면 돼요. 한 번 해 볼까요?

> 누적 합의 첫 번째 값은 배열의 첫 번째 값과 같아요.

<p align="center">
<img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/80d61aad-8a80-40c2-9b35-8664b823b991" width="700px">
</p>

배열의 첫 번째 값까지 더한 합은 배열의 첫 번째 값과 같기 때문이에요.

> 두 번째 값부터 채울 때에는, 직전에 구했던 합과 현재 배열의 값을 더한 값을 저장해요.

<p align="center">
   <img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/6aaf6799-cb29-4d4b-a2a7-5bc56c8c4813" width="700px">
   </p>

예를 들면 누적 합 배열의 $i$ 번째 값을 채울 때는 $(i - 1)$ 번째 누적 합 배열의 값과 배열의 $i$ 번째 값을 더한 것이 돼요. 식으로 나타낸다면 아래와 같겠죠!

<p align="center">$prefix[i] = prefix[i - 1] + array[i]$</p>

이렇게 계산한다면, 누적 합 배열의 각 값을 채울 때 일일이 첫 번째부터 $i$ 번째 값까지 더하는 비효율적인 방법을 사용하지 않아도 됩니다!

위의 과정을 모두 마치셨다면, 누적 합 배열은 완성입니다! 이제 만든 누적 합 배열을 이용해 효율적으로 구간의 합을 구하고, 여왕의 질문에 대답해 봅시다!

<p align="center">
<img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/2a46648b-6b6f-4ec3-ba32-c90bae1e2f9f" width="700px">
</p>

> $x$ 번째 카드부터 $y$ 번째 카드까지 적힌 수를 모두 더한 합은?

먼저, 우리가 계산해야 하는 값은 $y$ 번째 값까지이므로, $1$ 번째 값부터 $y$ 번째 값까지의 합을 먼저 구합니다. 누적 합 배열에서 미리 계산해 두었으니 답을 바로 알아낼 수 있네요!

> $1$ 번째 값부터 $y$ 번째 값까지의 합은 $prefix[y]$ 입니다.

그리고, 이 상태에서 불필요한 구간의 합을 빼 주면 됩니다. 우리가 원하는 값은 $x$ 번째 수부터 $y$ 번째 수이죠? 그렇다면 불필요함에도 불구하고 값이 더해진 구간은 $1$ 번째 수부터 $(x - 1)$ 번째 수까지가 됩니다.

> $1$ 번째 값부터 $(x - 1)$ 번째 값까지의 합은 $prefix[x - 1]$ 이고, 이 부분이 $x$ 번째 수부터 $y$ 번째 수의 합을 구하기 위해 빼 주어야 하는 부분이 됩니다.

따라서, $x$ 번째 값부터 $y$ 번째 값까지의 합은 아래의 식과 같게 됩니다.

<p align="center">$prefix[y] - prefix[x - 1]$</p>

기존 방법인 모든 수를 처음부터 끝까지 일일이 더하는 방식은 시간복잡도가 $O(NM)$ 이었습니다. 반면 누적 합을 만들어 질문에 대답하는 방법은...

- 누적 합을 만드는 데 드는 시간 복잡도 $O(N)$
- 한 번의 질문마다 연산 한 번에 답을 구할 수 있으므로 $O(1)$, $M$ 개의 질문에 답해야 하므로 $O(M)$

으로, 시간복잡도가 $O(N + M)$ 이 됩니다. 연산의 수로 따지자면 $2\\;000\\;000$ 으로, 기존 방식에서의 연산 수인 $1\\;000\\;000\\;000\\;000$ 와는 비교도 안 될 정도로 적은 수입니다.

이처럼 누적 합을 사용하면 보다 효율적으로 구간의 합을 구할 수 있게 됩니다. 앨리스의 궁금증도 해결이 되었겠군요!

## 누적 합의 한계

### 더 가혹해진 여왕의 카드 게임

앨리스는 무사히 집으로 돌아갔지만, 만약 하트 여왕이 더 얄팍한 꼼수를 썼다면 어떻게 되었을까요? 예를 들면, 하트 여왕이 **질문을 할 때마다 카드를 한 장 골라서 다른 수로 바꾼다면**요?

<p align="center">
<img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/b1db8af7-c071-49ac-83a3-1e7db7e73778" width="700px" />
</p>

위의 그림은 세 번째 카드에 적힌 수를 $3$ 에서 $1$ 로 바꾼 상황입니다. 카드에 적힌 수가 달라졌기에 이 이후의 누적합 배열의 값들을 다시 갱신해 주어야 합니다.

여기에서 $i$ 번째 카드에 적힌 수를 바꾸었다면, $(i, i + 1, i + 2, ...)$ 번째 칸의 누적 합도 갱신해 주어야 올바른 값이 저장됩니다. 최악의 경우 누적 합을 처음부터 다시 만들어야 하는 상황이 올 수 있습니다. 겨우 카드 한 장의 값을 바꿨을 뿐인데요!

누적 합을 다시 만드는 시간복잡도는 앞서 구했듯이, $O(N)$ 입니다. 여왕이 질문을 할 때마다 카드의 값을 다시 바꾼다면, 또다시 누적합을 만들어 주어야 합니다. 여왕이 하게 될 질문의 횟수를 $M$ 회라고 하면, 시간복잡도는 $O(NM)$ 이 되지요, 일일이 값을 하나씩 더해보는 기존 방식과 다를 바가 없게 됩니다.

### 누적 합의 한계, 그리고 이 한계를 극복하기 위해 사용해 볼 수 있는 방법들

**누적 합은 값이 변하지 않는 구간** 에서 여러 번 구간의 합을 구해야 할 때 유용합니다. 값이 자주 변한다면 그때마다 누적 합 배열을 다시 갱신해 줘야 하므로, 비효율적인 상황이 됩니다. 이것이 누적 합의 한계이죠.

누적 합으로는 이제 구간의 합을 빠르게 구할 수 없지만, 빈번하게 값이 바뀌는 상황에도 빠르게 답을 구할 수 있는 방법으로, **세그먼트 트리**, **느리게 갱신되는 세그먼트 트리**, **mo's** 등을 사용해 볼 수 있습니다.

## 끝내며

누적 합에 대한 저의 이야기는 여기까지입니다! 생소한 개념이었지만, 조금이나마 이해가 되는 데 도움이 되는 글이었기를 바랍니다. 이해가 당장 되지 않으셨더라도, 괜찮습니다! 이러한 알고리즘들의 필요성을 느끼셨다면, 그것으로 충분하다고 생각합니다. 나중에 문제를 풀다가, 앨리스와 같은 불편함에 직면하셨을 때, 다시 이 글을 찾아 오시길 바래요.

알고리즘도 결국 효율적으로 문제를 풀기 위한 도구일 뿐입니다. 누군가가 시켜서 이러이러한 알고리즘을 무작정 사용하는 것보다는, 먼저 문제를 그대로 풀기에는 비효율적이라는 사실을 발견하고, 이러한 문제를 해결하기 위해서는 이러이러한 알고리즘을 사용하면 좋겠구나! 라는 생각을 떠올리시는데, 조금이라도 이 글이 도움을 주었기를 바래요.

감사합니다!
