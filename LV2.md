## 하트 여왕과 카드 더하기 게임

<p align="center">
  <img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/9155a80f-6ef4-4ca1-b1fd-1ecc97584060" width="700px"/>
</p>

어쩌다가 하트 여왕의 왕국 안에서 눈을 뜬 앨리스. 원래 세계로 돌아가려면, 하트 여왕과 카드 게임을 해서 이겨야만 합니다.

규칙은 간단합니다. 하트 여왕이 카드를 일렬로 늘어놓고, 특정 구간의 카드들을 선택한 뒤, 이 카드들의 합을 묻습니다. 합을 정확하게 대답한다면 게임에서 이기게 됩니다. 원래 세계로 돌아가기 위해, 앨리스는 게임에 응했고, 여왕은 질문을 하기 시작했습니다.

### #1

> $3$ 번째 카드부터 $6$ 번째 카드까지 적힌 수를 모두 더한 합은?

$3$ 번째 카드부터 $6$ 번째 카드까지 적힌 수는 각각 $3$, $5$, $2$, $4$ 이므로, 앨리스는 간단한 덧셈으로 $3 + 5 + 2 + 4 = 14$ 를 외쳤습니다.

### #2

화가 난 여왕은 카드의 수를 무려 $1\\;000\\;000$ 장으로 늘렸습니다. 그리고 이전 방식과 동일하게 구간을 정해 앨리스에게 카드의 합을 물었습니다.

> $x$ 번째 카드부터 $y$ 번째 카드까지 적힌 수를 모두 더한 합은? ($1 \le x \le y \le 1\\;000\\;000$)

카드의 수가 엄청나게 많아졌지만, 앨리스는 노트북을 가지고 있었기에, $x$ 번째 카드부터 $y$ 번째 카드까지 일일이 더하는 코드를 작성해 합을 계산할 수 있었습니다.

```cpp

int sum = 0;

for (int i = x; i <= y; i++) {
    sum += cards[i];
}

cout << sum;
```

### #3

화가 머리끝까지 난 여왕은 앨리스가 도저히 합을 구할 수 없도록, 엄청나게 많은 수의 질문을 하기로 했습니다.

> $x$ 번째 카드부터 $y$ 번째 카드까지의 합을 맞춰 봐. 그런데 나는 너한테 이 질문을 최대 $1\\;000\\;000$ 번까지 할 거고, 질문을 할 때마다 $x$ 값과 $y$ 값은 새롭게 정할 거야. ($1 \le x \le y \le 1\\;000\\;000$)

앨리스도 이번에는 여러 번 $x$ 와 $y$ 를 입력받아 합을 계산하려고 했지만, 이번에는 문제가 생겼습니다. 합을 구하는 데 너무 시간이 오래 걸린 나머지, 앨리스는 답을 구하지 못 했고, 게임에서 지게 되었습니다.

```cpp
for (int t = 1; t <= 1000000; t++) {
    int sum = 0;
    cin >> x >> y;

    for (int i = x; i <= y; i++) {
        sum += cards[i];
    }

    cout << sum;
}
```

## 왜 앨리스의 코드는 시간이 너무 오래 걸렸던 걸까요

### 컴퓨터는 1초에 이 정도의 연산을 할 수 있어요

**알고리즘 문제풀이에서, 컴퓨터가 $1$ 초에 할 수 있는 연산의 횟수는 보통 수 억번 정도로 두는 경우가 많아요.** 물론 이 연산의 횟수는 연산 한 번당 얼마나 많은 시간이 걸리는지, 얼마나 연산이 무거운지에 따라 달라질 수는 있어요.

### 최악의 상황을 가정해 볼까요

**알고리즘은 주어진 조건 내에서 어떤 입력이 주어지든, 안정적인 시간 안에 답을 낼 수 있어야 해요. 입력이 가장 많고 복잡한 최악의 상황이 주어져도 말이죠.**

하트 여왕의 카드 게임에서는, 카드가 $1\\;000\\;000$ 장이고, 여왕이 질문을 $1\\;000\\;000$ 번 하며, 매 질문마다 $1\\;000\\;000$ 장의 카드 모두의 합을 계산하라고 묻는 것이 최악의 상황일 거에요.

매 질문마다 앨리스가 작성한 프로그램은 $1\\;000\\;000$ 장의 카드를 모두 확인해 볼 것이고, 이 상황이 $1\\;000\\;000$ 번 반복될 것이기에, 카드의 수를 $N$, 질문의 수를 $M$ 이라 한다면 앨리스의 코드의 시간복잡도는 $O(NM)$ 이 되고, 연산 횟수는 무려 $1\\;000\\;000\\;000\\;000$ 회나 될 것입니다. $1$ 초에 할 수 있는 연산의 수를 수억 번이라 가정했을 때 상당히 오랜 시간이 걸릴 것이라는 것을 알 수 있고, 앨리스의 프로그램이 바로 답을 출력하지 못 할 것이라는 사실 역시 알 수 있어요.

따라서, 앨리스가 작성한 코드는 여왕의 질문에 모두 대답하기에는 너무 비효율적이에요. 더 효율적으로 합을 계산하고 앨리스가 게임을 이기게 할 방법은 없을까요?

## 누적 합을 이용해, 더 효율적으로 합을 구해 봅시다!

다행히도, 앨리스가 여왕의 질문에 모두 대답하고 게임을 이길 수 있는 방법은 여전히 있답니다! 누적 합 알고리즘과 함께라면 가능해요.

**누적 합** 알고리즘은 **특정 구간에 있는 연속된 수들의 합을 빠르게 구할 수 있는** 알고리즘이에요. **수들의 합을 미리 저장해 두었다가, 필요할 때 재사용하는 방식**을 사용하여 붋필요한 연산을 줄이고 시간을 대폭 줄일 수 있답니다.

### 누적 합 배열 만들기

누적 합 알고리즘을 사용하려면 먼저 수들의 합을 미리 저장해 둔 **누적 합 배열**이 필요해요. 이 배열을 먼저 만들어 봅시다.

누적 합 배열을 만들 때에는 **누적 합 배열의 $i$ 번째 값이 $1$ 번째 값부터 $i$ 번째 값**까지의 합이 되도록 채우면 돼요. 한 번 해 볼까요?

> 누적 합의 첫 번째 값은 배열의 첫 번째 값과 같아요.

<p align="center">
<img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/80d61aad-8a80-40c2-9b35-8664b823b991" width="700px">
</p>

배열의 첫 번째 값까지 더한 합은 배열의 첫 번째 값과 같기 때문이에요.

> 두 번째 값부터 채울 때에는, 직전에 구했던 합과 현재 배열의 값을 더한 값을 저장해요.

<p align="center">
   <img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/6aaf6799-cb29-4d4b-a2a7-5bc56c8c4813" width="700px">
   </p>

예를 들면 누적 합 배열의 $i$ 번째 값을 채울 때는 $(i - 1)$ 번째 누적 합 배열의 값과 배열의 $i$ 번째 값을 더한 것이 돼요. 식으로 나타낸다면 아래와 같겠죠!

<p align="center">$prefix[i] = prefix[i - 1] + array[i]$</p>

이렇게 계산한다면, 누적 합 배열의 각 값을 채울 때 일일이 첫 번째부터 $i$ 번째 값까지 더하는 비효율적인 방법을 사용하지 않아도 됩니다!

위의 과정을 모두 마치셨다면, 누적 합 배열은 완성입니다! 이제 만든 누적 합 배열을 이용해 효율적으로 구간의 합을 구하고, 여왕의 질문에 대답해 봅시다!

<p align="center">
<img src="https://github.com/wzrabbit/boj-totamjung/assets/87642422/2a46648b-6b6f-4ec3-ba32-c90bae1e2f9f" width="700px">
</p>

> $x$ 번째 카드부터 $y$ 번째 카드까지 적힌 수를 모두 더한 합은?

먼저, 우리가 계산해야 하는 값은 $y$ 번째 값까지이므로, $1$ 번째 값부터 $y$ 번째 값까지의 합을 먼저 구합니다. 누적 합 배열에서 미리 계산해 두었으니 답을 바로 알아낼 수 있네요!

> $1$ 번째 값부터 $y$ 번째 값까지의 합은 $prefix[y]$ 입니다.

그리고, 이 상태에서 불필요한 구간의 합을 빼 주면 됩니다. 우리가 원하는 값은 $x$ 번째 수부터 $y$ 번째 수이죠? 그렇다면 불필요함에도 불구하고 값이 더해진 구간은 $1$ 번째 수부터 $(x - 1)$ 번째 수까지가 됩니다.

> $1$ 번째 값부터 $(x - 1)$ 번째 값까지의 합은 $prefix[x - 1]$ 이고, 이 부분이 $x$ 번째 수부터 $y$ 번째 수의 합을 구하기 위해 빼 주어야 하는 부분이 됩니다.

따라서, $x$ 번째 값부터 $y$ 번째 값까지의 합은 아래의 식과 같게 됩니다.

<p align="center">$prefix[y] - prefix[x - 1]$</p>

기존 방법인 모든 수를 처음부터 끝까지 일일이 더하는 방식은 시간복잡도가 $O(NM)$ 이었습니다. 반면 누적 합을 만들어 질문에 대답하는 방법은...

- 누적 합을 만드는 데 드는 시간 복잡도 $O(N)$
- 한 번의 질문마다 연산 한 번에 답을 구할 수 있으므로 $O(1)$, $M$ 개의 질문에 답해야 하므로 $O(M)$

으로, 시간복잡도가 $O(N + M)$ 이 됩니다. 연산의 수로 따지자면 $2\\;000\\;000$ 으로, 기존 방식에서의 연산 수인 $1\\;000\\;000\\;000\\;000$ 와는 비교도 안 될 정도로 적은 수입니다.

이처럼 누적 합을 사용하면 보다 효율적으로 구간의 합을 구할 수 있게 됩니다. 앨리스의 궁금증도 해결이 되었겠군요!
